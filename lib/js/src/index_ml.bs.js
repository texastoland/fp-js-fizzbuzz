// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
"use strict";

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Int$BsAbstract = require("bs-abstract/lib/js/src/implementations/Int.bs.js");
var Array$BsAbstract = require("bs-abstract/lib/js/src/implementations/Array.bs.js");
var Option$BsAbstract = require("bs-abstract/lib/js/src/implementations/Option.bs.js");
var PPX_Let$BsAbstract = require("bs-abstract/lib/js/src/interfaces/PPX_Let.bs.js");
var Function$BsAbstract = require("bs-abstract/lib/js/src/implementations/Function.bs.js");
var Functors$BsAbstract = require("bs-abstract/lib/js/src/utilities/Functors.bs.js");

var FoldMapAOS = Curry._1(
  Array$BsAbstract.Foldable[/* Fold_Map */ 2],
  Functors$BsAbstract.OptionF[/* String */ 3][/* Monoid */ 2]
);

var PPXLetA = PPX_Let$BsAbstract.Make(Array$BsAbstract.Monad);

function cond(test, s, i) {
  if (Curry._1(test, i)) {
    return s;
  }
}

function game(rules, i) {
  var applyRule = function(f) {
    return Curry._1(f, i);
  };
  return Curry._2(
    Option$BsAbstract.Infix[/* |? */ 8],
    Int$BsAbstract.Show[/* show */ 0](i),
    Curry._2(FoldMapAOS[/* fold_map */ 0], applyRule, rules)
  );
}

function divis(by, i) {
  return Caml_int32.mod_(i, by) === 0;
}

var partial_arg = "üê≠";

var partial_arg$1 = "üê±";

var partial_arg$2 = "üê∂";

var rules = /* array */ [
  function(param) {
    return cond(
      function(param) {
        return divis(3, param);
      },
      partial_arg,
      param
    );
  },
  function(param) {
    return cond(
      function(param) {
        return divis(5, param);
      },
      partial_arg$1,
      param
    );
  },
  function(param) {
    return cond(
      function(param) {
        return divis(7, param);
      },
      partial_arg$2,
      param
    );
  }
];

function range2D(w, h) {
  return Curry._2(
    PPXLetA[/* Let_syntax */ 0][/* map */ 2],
    Belt_Array.range(0, (h - 1) | 0),
    function(i) {
      return Belt_Array.range(
        (Caml_int32.imul(i, w) + 1) | 0,
        Caml_int32.imul((i + 1) | 0, w)
      );
    }
  );
}

console.log(
  Curry._4(
    Function$BsAbstract.Infix[/* <. */ 0],
    Array$BsAbstract.Functor[/* map */ 0],
    Array$BsAbstract.Functor[/* map */ 0],
    function(param) {
      return game(rules, param);
    },
    range2D(10, 10)
  )
);

var $neg$neg = Belt_Array.range;

exports.FoldMapAOS = FoldMapAOS;
exports.PPXLetA = PPXLetA;
exports.cond = cond;
exports.game = game;
exports.divis = divis;
exports.rules = rules;
exports.$neg$neg = $neg$neg;
exports.range2D = range2D;
/* FoldMapAOS Not a pure module */
